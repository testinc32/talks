<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Exploiting Ruby's AST - a love story in 3 chapters</title>

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/white.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
          <h3>Exploiting Ruby's abstract syntax tree</h3>
          <h4>A love story in 3 chapters</h4>
          <img data-src="img/exploiting_rubys_ast/love_story.jpg">
      </section>

      <section>
        <h3>Who am I?</h3>
        <p class="fragment">Timo Rößner</p>
        <p class="fragment">Berlin, Germany</p>
        <p class="fragment">Director of Engineering @ Blacklane</p>
        <p class="fragment">Part of the <a href="https://github.com/troessner/reek">Reek</a> and <a href="https://github.com/whitesmith/rubycritic">RubyCritic</a> core team</p>
      </section>

      <section>
        <h3>What is an Abstract Syntax Tree?</h3>
        <p class="fragment">Or: How does a computer run your program?</p>
      </section>

      <section>
        <h3>So what happens between...</h3>
        <pre><code class="ruby">
          def foo
            puts 'hola!'
          end
        </code></pre>
        <p>and</p>
        <pre><code class="ruby">
          foo() # -> hola!
        </code></pre>
        <p>?</p>
      </section>

      <section>
        <h3>Stage 1</h3>
        <h4>Tokenization</h4>
        <p>...is the process of breaking a stream of text into meaningful elements called tokens</p>
        <pre><code class="ruby">
          Ripper.tokenize "def foo; puts 'hola!' end"
        </code></pre>
        <pre><code class="ruby">
          ["def",
           "foo",
           ";",
           "puts",
           "'",
           "hola!",
           "'",
           "end"]
        </code></pre>
      </section>

      <section>
        <h3>Stage 2: Lexing</h3>
        <p>...is the process of giving meaning to these tokens</p>
        <p>Lexing via</p>
        <!--
          Example below requires the following lines before running:
             require 'parser/current'
             require 'parser/source/buffer'
        -->
        <pre><code class="ruby">
           buffer = Parser::Source::Buffer.new('buffer', 1)
           buffer.source = "def foo; puts 'hola!' end"
           Parser::CurrentRuby.new.tokenize(buffer)
        </code></pre>
        <p>would yield:</p>
        <pre><code class="ruby">
          [[:kDEF, ["def", #<Parser::Source::Range buffer 0...3>]],
           [:tIDENTIFIER, ["foo", #...]],
           [:tSEMI, [";", , #...]],
           [:tIDENTIFIER, ["puts", #...]],
           [:tSTRING, ["hola!", , #...]],
           [:kEND, ["end", , #...]],
        </code></pre>
      </section>

      <section>
        <h3>Stage 3: Parsing</h3>
        <p>...is the process of taking those tokens and creating an abstract syntax tree</p>
        <pre><code class="ruby">
          Parser::CurrentRuby.parse "def foo; puts 'hola!' end"
        </code></pre>
        <pre><code class="ruby">
            s(:def, :foo,
              s(:args),
                s(:send, nil, :puts,
                  s(:str, "hola!")))
        </code></pre>
      </section>

      <section>
        <h3>Stage 4: Compiling to Bytecode</h3>
        <p>...is the process of taking the AST and turning it into instruction sequences for the Ruby VM</p>
        <pre><code class="ruby">
            RubyVM::InstructionSequence.
              compile('def foo; end').
              disassemble
        </code></pre>
        <pre><code class="bash">
            putobject :foo\n0008
            putiseq   foo\n0010
            opt_send_without_block ... \n0012
        </code></pre>
      </section>

      <section>
        <h3>Stage 5: Compile to native code and run</h3>
        <p>TODO: Further explanations missing</p>
      </section>

      <section>
        <h3>So, Abstract Syntax Trees?</h3>
        <p class="fragment">Consists of s-expressions ("symbolic expression")</p>
        <p class="fragment">s-expressions are a notation for nested list (tree-structured) data</p>
        <p class="fragment">Invented for and popularized by Lisp</p>
        <p>TODO: Here we need a nice tree picture of my code sample from before</p>
      </section>

      <section>
        <h3>Why "abstract"?</h3>
        <!-- For a counter example to below see:
          http://rorbservations.com/post/136816741674/rubys-unless-x-is-processed-differently
        -->
        <p>Because an AST doesn't represent every detail that appears in
            the real syntax</p>
        <pre><code class="ruby">
            :foo if :bar
        </code></pre>
        <p>and</p>
        <pre><code class="ruby">
            if :bar then :foo; end
        </code></pre>
        <p>will result in the same AST (and thus bytecode as well):</p>
        <pre><code class="ruby">
          s(:if,
            s(:sym, :bar),
              s(:sym, :foo), nil)
        </code></pre>
      </section>

      <section>
        <h3>Ok, sounds great! What can I do with it?</h3>
      </section>

      <section>
        <h3>Chapter 1 - linting</h3>
        <p> Linting is....</p>
      </section>

      <section>
        <h3>Rubocop</h3>
        <p> ...</p>
      </section>

      <section>
        <h3>How does rubocop work?</h3>
        <ul>
          <li><a href="https://github.com/bbatsov/rubocop/blob/master/lib/rubocop/processed_source.rb#L100">uses the parser gem</a></li>
          <li><a href="https://github.com/bbatsov/rubocop/blob/master/lib/rubocop/processed_source.rb#L89">builds up an AST</a></li>
          <li><a href="https://github.com/bbatsov/rubocop/blob/master/lib/rubocop/runner.rb#L190">Passes this AST to each cop</a></li>
        </ul>
      </section>

      <section>
        <h3>Chapter 2</h3>
        <h4>Code Smells</h4>
        <img data-src="img/exploiting_rubys_ast/code_smells.jpg">
      </section>

      <section>
        <h3>Code Smells</h3>
        <p class="fragment">A code smell is a hint that something might be wrong, not a certainty</p>
        <p class="fragment">Calling something a code smell is not an attack; it’s simply a sign that a closer look is warranted</p>
      </section>

      <section>
        <h3>There are easy code smells</h3>
        <p>TODO</p>
      </section>

      <section>
        <h3>But there are also not so obvious, complicated smells</h3>
        <pre><code class="ruby">
            class Warehouse
              def sale_price(item)
                (item.price - item.rebate) * @vat
              end
            end
        </code></pre>
        <p>This would be FeatureEnvy since</p>
        <pre><code class="ruby">
          (item.price - item.rebate)
        </code></pre>
        <p>belongs to the <i>Item</i> class, not the <i>Warehouse</i>.</p>
      </section>

      <section>
        <h3>Reek is a tool that detects code smells</h3>
        <p>Running Reek on</p>
        <pre><code class="ruby">
            class Warehouse
              def sale_price(item)
                (item.price - item.rebate) * @vat
              end
            end
        </code></pre>
        <p>would report:</p>
        <pre><code>
          Warehouse#total_price refers to item more than self (FeatureEnvy)
        </code></pre>
      </section>

      <section>
        <h3>How does Reek work?</h3>
        <p>TODO</p>
      </section>

      <section>
        <h3>Chapter 3</h3>
        <h4>Mutation testing</h4>
        <img data-src="img/exploiting_rubys_ast/supermutant.jpg">
      </section>

      <section>
        <h3>Mutation testing</h3>
        <p>Takes code like this</p>
        <pre><code class="ruby">
          class Greeter
            def initialize(phrase)
              @enabled = true
              @phrase = phrase
            end

            def say_hello(options)
              "#{@phrase} #{options[:name]}" if @enabled
            end
          end
        </code></pre>
      </section>

      <section>
        <h3>Mutation testing</h3>
        <p>And turns it into something like this</p>
        <pre><code class="ruby">
          # TODO: Add example and circle the difference red
        </code></pre>
        <p>Or this</p>
        <pre><code class="ruby">
          # TODO: Add example and circle the difference red
        </code></pre>
      </section>

      <section>
        <h3>Mutation testing (cont'd)</h3>
        <p>The mutator then runs your tests against each mutation</p>
        <pre><code class="bash">
          # TODO:
        </code></pre>
      </section>

      <section>
        <h3>Mutation testing (cont'd)</h3>
        <p>Failing tests kill the mutants</p>
        <pre><code class="bash">
          # TODO:
        </code></pre>
        <p>Surviving mutants show a lack of test coverage</p>
        <pre><code class="bash">
          # TODO:
        </code></pre>
      </section>

      <section>
          <h3>Wishlist</h3>
          <p> # String#to_ast </p>
          <p> # AST#compile </p>
      </section>

      <section>
          <h3> # Maybe</h3>
          <p> # Clojure? </p>
      </section>
    </div>
  </div>

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>

  <script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
            {
                src: 'lib/js/classList.js', condition: function () {
                return !document.body.classList;
            }
            },
            {
                src: 'plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'plugin/highlight/highlight.js', async: true, condition: function () {
                return !!document.querySelector('pre code');
            }, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {src: 'plugin/zoom-js/zoom.js', async: true},
            {src: 'plugin/notes/notes.js', async: true}
        ]
    });

  </script>

</body>
</html>
