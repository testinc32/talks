<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Exploiting Ruby's AST - a love story in 3 chapters</title>

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/white.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
          <h3>Exploiting Ruby's abstract syntax tree</h3>
          <h4>A love story in 3 chapters</h4>
          <img data-src="img/exploiting_rubys_ast/love_story.jpg">
      </section>

      <section>
        <h3>Who am I?</h3>
        <p class="fragment">Timo Rößner</p>
        <p class="fragment">Berlin, Germany</p>
        <p class="fragment">Director of Engineering @ Blacklane</p>
        <p class="fragment">Part of the <a href="https://github.com/troessner/reek">Reek</a> and <a href="https://github.com/whitesmith/rubycritic">RubyCritic</a> core team</p>
      </section>

      <section>
        <h3>Chapter 1</h3>
        <h4>What is an Abstract Syntax Tree?</h4>
        <p class="fragment">Or: How does a computer run your (Ruby) program?</p>
      </section>

      <section>
        <h3>So what happens between...</h3>
        <pre><code class="ruby">
          def foo
            puts 'hola!'
          end
        </code></pre>
        <p>and</p>
        <pre><code class="ruby">
          foo() # -> hola!
        </code></pre>
        <p>?</p>
      </section>

      <section>
        <h3>Stage 1</h3>
        <h4>Tokenization</h4>
        <p>...is the process of breaking a stream of text into meaningful elements called tokens</p>
        <pre class="fragment"><code class="ruby">
          Ripper.tokenize "def foo; puts 'hola!' end"
        </code></pre>
        <!-- TODO: Fix the overflowing display when adding the green arrow here and everywhere else -->
        <img width="48px" height="48px" style="border-style: none" class="fragment" data-src="img/exploiting_rubys_ast/green_arrow_down.png">
        <pre class="fragment"><code class="ruby">
          => ["def",
           "foo",
           ";",
           "puts",
           "'",
           "hola!",
           "'",
           "end"]
        </code></pre>
      </section>

      <section>
        <h3>Stage 2</h3>
        <h4>Lexing</h4>
        <p>...is the process of giving meaning to these tokens</p>
        <!--
          Example below requires the following lines before running:
             require 'parser/current'
             require 'parser/source/buffer'
        -->
        <pre class="fragment"><code class="ruby">
           buffer = Parser::Source::Buffer.new('buffer', 1)
           buffer.source = "def foo; puts 'hola!' end"

           Parser::CurrentRuby.new.tokenize(buffer)
        </code></pre>
        <img width="48px" height="48px" style="border-style: none" class="fragment" data-src="img/exploiting_rubys_ast/green_arrow_down.png">
        <pre class="fragment"><code class="ruby">
          [[:kDEF, ["def", #&ltParser::Source::Range buffer 0...3&gt]],
           [:tIDENTIFIER, ["foo", #...]],
           [:tSEMI, [";", , #...]],
           [:tIDENTIFIER, ["puts", #...]],
           [:tSTRING, ["hola!", , #...]],
           [:kEND, ["end", , #...]],
        </code></pre>
      </section>

      <section>
        <h3>Stage 3</h3>
        <h4>Parsing</h4>
        <p>...is the process of taking those tokens and creating an abstract syntax tree</p>
        <pre class="fragment"><code class="ruby">
          Parser::CurrentRuby.parse "def foo; puts 'hola!' end"
        </code></pre>
        <img width="48px" height="48px" style="border-style: none" class="fragment" data-src="img/exploiting_rubys_ast/green_arrow_down.png">
        <pre class="fragment"><code class="ruby">
            s(:def, :foo,
              s(:args),
                s(:send, nil, :puts,
                  s(:str, "hola!")))
        </code></pre>
        <!-- TODO: Add a proper tree diagram for this on the right side / column -->
      </section>

      <section>
        <h3>Stage 4</h3>
        <h4>Compiling to Bytecode</h4>

        <p>...is the process of taking the AST and turning it into instruction sequences for the Ruby VM</p>
        <pre class="fragment"><code class="ruby">
            RubyVM::InstructionSequence.
              compile('def foo; end').
              disassemble
        </code></pre>
        <img width="48px" height="48px" style="border-style: none" class="fragment" data-src="img/exploiting_rubys_ast/green_arrow_down.png">
        <pre class="fragment"><code class="bash">
            putobject :foo\n0008
            putiseq   foo\n0010
            opt_send_without_block ... \n0012
        </code></pre>
      </section>

      <section>
        <h3>Stage 5</h3>
        <h4>Compile to native code and run</h4>

        <p>TODO: Further explanations missing</p>
      </section>

      <section>
        <h3>Quick recap</h3>
        <h4>From source code to execution</h4>

        <!-- TODO: Replace image below with own, nicer looking one -->
        <img data-src="img/exploiting_rubys_ast/from_source_code_to_execution.png">
      </section>

      <section>
        <h3>Let's revisit Abstract Syntax Trees</h3>
        <p class="fragment">AST's consist of s-expressions ("symbolic expression")</p>
        <p class="fragment">s-expressions are a notation for nested list (tree-structured) data</p>
        <p class="fragment">Invented for and popularized by Lisp</p>
        <!-- TODO: Add a diagram for S-expressions and how the form an AST -->
      </section>

      <section>
        <h3>Why "abstract"?</h3>
        <!-- For a counter example to below see:
          http://rorbservations.com/post/136816741674/rubys-unless-x-is-processed-differently
        -->
        <p class="fragment">AST's don't represent every detail that appears in
            the real syntax</p>
        <pre class="fragment"><code class="ruby">
          :foo if :bar # Version 1
        </code></pre>
        <pre class="fragment"><code class="ruby">
          if :bar then :foo; end # Version 2
        </code></pre>
        <p class="fragment">Both versions will result in the same AST (and thus bytecode):</p>
        <pre class="fragment"><code class="ruby">
          s(:if,
            s(:sym, :bar),
              s(:sym, :foo), nil)
        </code></pre>
      </section>

      <section>
        <h3>So why would you care about any of this?</h3>
        <p class="fragment">There are a ton of cool things you can only do on an AST</p>
        <p class="fragment">If you understand AST's you just learned LISP for free</p>
        <p class="fragment">For this talk we'll focus on the "cool things" (TM)</p>
      </section>

      <section>
        <h3>Chapter 2</h3>
        <h4>Code Smells</h4>
        <img data-src="img/exploiting_rubys_ast/code_smells.jpg" width="70%" height="70%">
      </section>

      <section>
        <h3>Code Smells</h3>
        <p class="fragment">A code smell is a hint that something might be wrong, not a certainty</p>
        <p class="fragment">Calling something a code smell is not an attack</p> <!-- it’s simply a sign that a closer look is warranted -->
        <p class="fragment">No codebase is perfect</p> <!-- but it’s worthwhile to be aware of its deficiencies and refactorings that could improve the state of things -->
      </section>

      <section>
        <h3>There are conceptually simple code smells</h3>
        <!--
        <pre class="fragment"><code class="ruby">
          def m(a, b, c, d, e, f)
            @@klazzy_1 = call_me(f)
            @@klazzy_2 = call_me(f)
          end
        </code></pre>
        -->
        <img data-src="img/exploiting_rubys_ast/simple_smells.png">
      </section>

      <section>
        <h3>But there are also not so obvious, complicated smells</h3>
        <p class="fragment">Feature Envy occurs when a code fragment references another object more often than it references itself</p>
        <img class="fragment" data-src="img/exploiting_rubys_ast/feature_envy.png">
      </section>

      <section>
        <h3>Reek is a tool that detects code smells</h3>
        <p>Running Reek on</p>
        <pre><code class="ruby">
            class Warehouse
              def sale_price(item)
                (item.price - item.rebate) * @vat
              end
            end
        </code></pre>
        <img width="48px" height="48px" style="border-style: none" class="fragment" data-src="img/exploiting_rubys_ast/green_arrow_down.png">
        <pre class="fragment"><code>
          Warehouse#total_price refers to item more than self (FeatureEnvy)
        </code></pre>
      </section>

      <section>
        <h3>How does Reek work?</h3>
        <p class="fragment">We use the awesome parser gem to generate the AST</p>
        <!-- The lines below are too long apparently for displaying them properly -->
        <pre class="fragment"><code class="ruby">
          def syntax_tree
            begin
              ast, comments = parser.parse_with_comments(source, origin)
            rescue Racc::ParseError, Parser::SyntaxError => error
              $stderr.puts "#{origin}: #{error.class.name}: #{error}"
            end

            comment_map = Parser::Source::Comment.associate(ast, comments) if ast
            TreeDresser.new.dress(ast, comment_map)
          end
        </code></pre>
      </section>

      <section>
        <h3>How does Reek work? (cont'd)</h3>
        <p class="fragment">We wrap that into a tree of contexts</p>
        <pre class="fragment"><code class="ruby">
          def build(exp)
            context_processor = "process_#{exp.type}"
            if context_processor_exists?(context_processor)
              send(context_processor, exp)
            else
              process exp
            end
          end

          def process(exp)
            exp.children.grep(AST::Node).each(&method(:build))
          end

          def process_module(exp)
            inside_new_context(Context::ModuleContext, exp) do
              process(exp)
            end
          end
        </code></pre>
      </section>

      <section>
        <h3>How does Reek work? (cont'd)</h3>
        <p class="fragment">We then traverse this tree of contexts and run all eligible smell detectors on it</p>
        <! -- # TODO: Find a simple smell detector -->
        <pre class="fragment"><code class="ruby">
          # ....
        </code></pre>
      </section>

      <section>
        <h3>Chapter 3</h3>
        <h4>Mutation testing with Mutant</h4>
        <img data-src="img/exploiting_rubys_ast/supermutant.jpg">
      </section>

      <section>
        <h3>Mutation testing with Mutant</h3>
        <p>Takes code like this</p>
        <pre><code class="ruby">
          class Greeter
            def initialize(phrase)
              @enabled = true
              @phrase = phrase
            end

            def say_hello(options)
              "#{@phrase} #{options[:name]}" if @enabled
            end
          end
        </code></pre>
      </section>

      <section>
        <h3>Mutation testing with Mutant</h3>
        <p>And turns it into something like this</p>
        <!-- TODO: Screenshot this and circle the difference red with sketch.io -->
        <pre><code class="ruby">
           if true
             "#{@phrase}#{" "}#{options[:name]}"
           end
        </code></pre>
      </section>

      <section>
        <h3>Mutation testing with Mutant</h3>
        <p>Or this</p>
        <!-- TODO: Screenshot this and circle the difference red with sketch.io -->
        <pre><code class="ruby">
          if @enabled
            "#{@phrase}#{" "}#{options.fetch(:name)}"
          end
        </code></pre>
      </section>

      <section>
        <h3>Mutation testing with Mutant</h3>
        <p>The mutator then runs your tests against each mutation</p>
        <pre><code class="bash">
          bundle exec mutant --include lib/ --require ast_talk_samples --use rspec  "Greeter*"

          Mutant configuration:
          Matcher:         #&ltMutant::Matcher::Config match_expressions: [Greeter*]&gt
          Integration:     Mutant::Integration::Rspec
          Expect Coverage: 100.00%
          Jobs:            4
          Includes:        ["lib/"]
          Requires:        ["ast_talk_samples"]
        </code></pre>
      </section>

      <section>
        <h3>Mutation testing with Mutant</h3>
        <p>Failing tests kill the mutants</p>
        <p>Surviving mutants show a lack of test coverage</p>
        <pre><code class="bash">
            evil:Greeter#say_hello:/Users/timo/dev/ast_talk_samples/lib/mutant/greeter.rb:7:80e67
            @@ -1,6 +1,6 @@
             def say_hello(options)
            -  if @enabled
            +  if true
                 "#{@phrase}#{" "}#{options[:name]}"
               end
             end
         </code></pre>
      </section>

      <section>
        <h3>How does <i>Mutant</i> work?</h3>
        <!-- TODO ....-->
      </section>
    </div>
  </div>

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>

  <script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
            {
                src: 'lib/js/classList.js', condition: function () {
                return !document.body.classList;
            }
            },
            {
                src: 'plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'plugin/highlight/highlight.js', async: true, condition: function () {
                return !!document.querySelector('pre code');
            }, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {src: 'plugin/zoom-js/zoom.js', async: true},
            {src: 'plugin/notes/notes.js', async: true}
        ]
    });

  </script>

</body>
</html>
