<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Exploiting Ruby's AST - a love story in 3 chapters</title>

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <meta name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/white.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">

    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
        <section>
            <h1>Exploiting Ruby's abstract syntax tree</h1>
            <h3>A love story in 3 chapters</h2>
        </section>

        <section>
            <h2>Who am I?</h2>
            <ul>
                <li>Timo Rößner</li>
                <li>Berlin, Germany</li>
                <li>Director of Engineering @ Blacklane</li>
                <li>Part of the <a href="https://github.com/troessner/reek">Reek</a> and <a
                        href="https://github.com/whitesmith/rubycritic">RubyCritic</a> core team
                </li>
            </ul>
        </section>

        <section>
            <h2>What is an Abstract Syntax Tree?</h2>
            <p class="fragment">To answer this question, we need to answer another question first</p>
            <p class="fragment">How does a computer run your program?</p>
        </section>

        <section>
            <h2>Or, to put it differently...</h2>
            <p>what happens between</p>
            <pre><code class="ruby">
                def foo
                  puts 'hola!'
                end
            </code></pre>
            <p>and</p>
            <pre><code class="ruby">
                foo() # -> hola!
            </code></pre>
            <p>?</p>
        </section>

        <section>
            <h2>Stage 1: Tokenization</h2>
            <p>...is the process of breaking a stream of text up into words, phrases, symbols, or other meaningful
                elements called tokens</p>
            <pre><code class="ruby">
              Ripper.tokenize "def foo; puts 'hola!' end"
            </code></pre>
            <pre><code class="ruby">
                ["def", " ", "foo", ";",
                " ", "puts", " ", "'", "hola!",
                "'", " ", "end"]
            </code></pre>
            <!-- For achieving the same using `parser`, not `ripper`

                 require 'parser/current'
                 require 'parser/source/buffer'
                 buffer = Parser::Source::Buffer.new('buffer', 1)
                 buffer.source = "def foo; puts 'hola!' end"
                 Parser::CurrentRuby.new.tokenize(buffer)
            -->
        </section>

        <section>
            <h2>Stage 2: Lexing</h2>
            <p>...is the process of giving meaning to these tokens</p>
            <pre><code class="ruby">
                Ripper.lex "def foo; puts 'hola!' end"
            </code></pre>
            <pre><code class="ruby">
                [[1, 0], :on_kw, "def"],
                [[1, 3], :on_sp, " "],
                [[1, 4], :on_ident, "foo"],
                [[1, 7], :on_semicolon, ";"],
                # ....
            </code></pre>
        </section>

        <section>
            <h2>Stage 3: Parsing</h2>
            <p>...is the process of taking those tokens and creating an abstract syntax tree</p>

            <pre><code class="ruby">
                Parser::CurrentRuby.parse "def foo; puts 'hola!' end"
            </code></pre>
            <pre><code class="ruby">
                s(:def, :foo,
                  s(:args),
                    s(:send, nil, :puts,
                      s(:str, "hola!")))
            </code></pre>
        </section>

        <section>
            <h2>Stage 4: Compiling</h2>
            <p>...is the process of taking the AST and turning it into instruction sequences for the Ruby VM</p>
            <p>TODO: Further explanations missing</p>
        </section>

        <section>
            <h2>So, Abstract Syntax Trees?</h2>
            <p class="fragment">Consists of s-expressions ("symbolic expression")</p>
            <p class="fragment">s-expressions are a notation for nested list (tree-structured) data</p>
            <p class="fragment">Invented for and popularized by Lisp</p>
            <p>TODO: Here we need a nice tree picture of my code sample from before</p>
        </section>

        <section>
            <h2>Why "abstract"?</h2>
            <!-- For a counter example to below see:
              http://rorbservations.com/post/136816741674/rubys-unless-x-is-processed-differently
            -->
            <p>Because an AST doesn't represent every detail that appears in
                the real syntax</p>
            <pre><code class="ruby">
                :foo if :bar
            </code></pre>
            <p>and</p>
            <pre><code class="ruby">
                if :bar then :foo; end
            </code></pre>
            <p>will result in the same AST (and thus bytecode as well):</p>
            <pre><code class="ruby">
              s(:if,
                s(:sym, :bar),
                s(:sym, :foo), nil)
            </code></pre>
        </section>

        <section>
            <h2>How to exploit an AST - chapter 1</h2>
            <h3> Enforce styleguides and linting</h3>
            <p> # Rubocop example</p>
        </section>

        <section>
            <h2>How to exploit an AST - chapter 1</h2>
            <h3>How does rubocop do this?</h3>
            <ul>
                <li><a href="https://github.com/bbatsov/rubocop/blob/master/lib/rubocop/processed_source.rb#L100">uses
                    the parser gem</a></li>
                <li><a href="https://github.com/bbatsov/rubocop/blob/master/lib/rubocop/processed_source.rb#L89">builds
                    up an AST</a></li>
                <li><a href="https://github.com/bbatsov/rubocop/blob/master/lib/rubocop/runner.rb#L190">Passes this AST
                    to each cop</a></li>
            </ul>
        </section>

        <section>
            <h2>How to exploit an AST - chapter 2</h2>
            <h3>Detect high level code smells</h3>
            <p>A code smell is a hint that something might be wrong, not a certainty. A perfectly good idiom may be
                considered a code smell because it’s often misused, or because there’s a simpler alternative that works
                in most cases. Calling something a code smell is not an attack; it’s simply a sign that a closer look is
                warranted.</p>
        </section>

        <section>
            <h2>How to exploit an AST - chapter 3</h2>
            <h3>Mutation testing</h3>
        </section>

        <section>
            <h2>Wishlist</h2>
            <p> # String#to_ast </p>
            <p> # AST#compile </p>
        </section>

        <section>
            <h2> # Maybe</h2>
            <p> # Clojure? </p>
        </section>
    </div>

</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
            {
                src: 'lib/js/classList.js', condition: function () {
                return !document.body.classList;
            }
            },
            {
                src: 'plugin/markdown/marked.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            }
            },
            {
                src: 'plugin/highlight/highlight.js', async: true, condition: function () {
                return !!document.querySelector('pre code');
            }, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {src: 'plugin/zoom-js/zoom.js', async: true},
            {src: 'plugin/notes/notes.js', async: true}
        ]
    });

</script>

</body>
</html>
