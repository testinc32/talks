<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/white.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/github.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h3>Exploiting Ruby's abstract syntax tree</h3>
          <h4>A love story in 3 chapters</h4>
          <img data-src="img/love_story.jpg">
        </section>

        <section>
          <h3>Who am I?</h3>
          <p class="fragment"><a href="https://branded.me/troessner">Timo Rößner</a></p>
          <p class="fragment">Berlin, Germany</p>
          <p class="fragment">Director of Engineering @ <a href="https://www.blacklane.com">Blacklane</a></p>
          <p class="fragment">Part of the <a href="https://github.com/troessner/reek">Reek</a> and <a href="https://github.com/whitesmith/rubycritic">RubyCritic</a> core team</p>
        </section>

        <section>
          <h3>Chapter 1</h3>
          <h4>What is an Abstract Syntax Tree?</h4>
          <p class="fragment">Or: How does Ruby run your program?</p>
        </section>

        <section>
          <p>So what happens between...</p>
          <pre><code class="ruby">
            def foo
              puts 'hola!'
            end
          </code></pre>
          <p>and</p>
          <pre><code class="ruby">
            foo() # -> hola!
          </code></pre>
          <p>?</p>
          <p>TODO: Naming everything foo and bar sucks, come up with better names that tell a story or at least have some meaning</p>
        </section>

        <section>
          <h3>Stage 1</h3>
          <h4>Tokenization</h4>
          <p>...is the process of breaking a stream of text into meaningful elements called tokens</p>
          <pre class="fragment"><code class="ruby">
            Ripper.tokenize "def foo end"
          </code></pre>
          <img width="48px" height="48px" style="border-style: none" class="fragment" data-src="img/green_arrow_down.png">
          <pre class="fragment"><code class="ruby">
            ["def", " ", "foo", " ", "end"]
          </code></pre>
        </section>

        <section>
          <h3>Stage 2</h3>
          <h4>Lexing</h4>
          <p>...is the process of giving meaning to these tokens</p>
          <!--
            Example below requires the following lines before running:
               require 'parser/current'
               require 'parser/source/buffer'
          -->
          <pre class="fragment"><code class="ruby">
             buffer = Parser::Source::Buffer.new('buffer', 1)
             buffer.source = "def foo end"
             Parser::CurrentRuby.new.tokenize(buffer)
          </code></pre>
          <img width="48px" height="48px" style="border-style: none" class="fragment" data-src="img/green_arrow_down.png">
          <pre class="fragment"><code class="ruby">
             [[:kDEF, ["def", #&lt;Parser::Source::Range 0...3&gt;]],
              [:tIDENTIFIER, ["foo", #&lt;Range 4...7&gt;],
              [:kEND, ["end", #&lt;Range 8...11&gt;]]]]
          </code></pre>
        </section>

        <section>
          <h3>Stage 3</h3>
          <h4>Parsing</h4>
          <p>...is the process of creating an abstract syntax tree out of those tokens</p>
          <pre class="fragment"><code class="ruby">
            Parser::CurrentRuby.parse "def foo; puts 'hola!' end"
          </code></pre>
          <img width="48px" height="48px" style="border-style: none" class="fragment" data-src="img/green_arrow_down.png">
          <pre class="fragment"><code class="ruby">
              s(:def, :foo,
                s(:args),
                s(:send, nil, :puts,
                  s(:str, "hola!")))
          </code></pre>
        </section>

        <section>
          <h3>Stage 4</h3>
          <h4>Compiling to Bytecode</h4>

          <p>...is the process of turning this AST into instruction sequences for the Ruby VM</p>
          <pre class="fragment"><code class="ruby">
              RubyVM::InstructionSequence.
                compile('def foo; end').
                disassemble
          </code></pre>
          <img width="48px" height="48px" style="border-style: none" class="fragment" data-src="img/green_arrow_down.png">
          <pre class="fragment"><code class="bash">
              putobject :foo\n0008
              putiseq   foo\n0010
              opt_send_without_block ... \n0012
          </code></pre>
        </section>

        <section>
          <h3>Stage 5</h3>
          <h4>Pass bytecode to the interpreter and run it</h4>

          <pre class="fragment"><code class="bash">
              putobject :foo\n0008
              putiseq   foo\n0010
              opt_send_without_block ... \n0012
          </code></pre>
          <img width="48px" height="48px" style="border-style: none" class="fragment" data-src="img/green_arrow_down.png">
          <p class="fragment">Ruby Interpreter</p>
        </section>

        <section>
          <h3>Quick recap</h3>
          <h4>From source code to execution</h4>

          <!-- TODO: Replace image below with own, nicer looking one -->
          <img data-src="img/from_source_code_to_execution.png" style="border-style: none" width="1000px" height="150px">
        </section>

        <section>
          <h3>Let's revisit Abstract Syntax Trees</h3>
          <p class="fragment">A syntax tree consists of nodes and edges</p>
          <!--
          1 + ( 2 * 3 )
          -->
          <div><img class="fragment" style="border-style: none" data-src="img/1_plus_2_times_3_as_string.png"></div>
          <img width="48px" height="48px" style="border-style: none" class="fragment" data-src="img/green_arrow_down.png">
          <div>
            <img class="fragment" data-src="img/1_plus_2_times_3_as_tree.png" style="border-style: none" width="350px" height="300px">
          </div>
        </section>

        <section>
          <p>Nodes consist of s-expressions ("symbolic expression")</p>
          <p class="fragment">s-expressions are a notation for nested list (tree-structured) data</p>
          <pre class="fragment"><code class="ruby">
            s(:send,
              s(:int, 1), :+,
              s(:begin,
                s(:send,
                  s(:int, 2), :*,
                  s(:int, 3))))
          </code></pre>
        </section>

        <section>
          <h3>Why "abstract"?</h3>
          <!-- For a counter example to below see:
            http://rorbservations.com/post/136816741674/rubys-unless-x-is-processed-differently
          -->
          <p class="fragment">ASTs don't represent every detail that appears in
              the real syntax</p>
          <pre class="fragment"><code class="ruby">
            :foo if :bar # Version 1
          </code></pre>
          <pre class="fragment"><code class="ruby">
            if :bar then :foo; end # Version 2
          </code></pre>
          <p class="fragment">Both versions will result in the same AST</p>
          <pre class="fragment"><code class="ruby">
            s(:if,
              s(:sym, :bar),
                s(:sym, :foo), nil)
          </code></pre>
        </section>

        <section>
          <h3>So why would you care about any of this?</h3>
          <p class="fragment">There are a ton of cool things you can only do on an AST</p>
          <p class="fragment">If you understand ASTs you just learned LISP for free</p>
          <p class="fragment">For this talk we'll focus on the "cool things" &reg;</p>
        </section>

        <section>
          <h3>Chapter 2</h3>
          <h4>Code Smells</h4>
          <img data-src="img/code_smells.jpg" width="70%" height="70%">
        </section>

        <section>
          <h3>Code Smells</h3>
          <p class="fragment">A code smell is a hint that something might be wrong, not a certainty</p>
          <p class="fragment">Calling something a code smell is not an attack</p> <!-- it’s simply a sign that a closer look is warranted -->
          <p class="fragment">No codebase is perfect</p> <!-- but it’s worthwhile to be aware of its deficiencies and refactorings that could improve the state of things -->
        </section>

        <section>
          <h3>There are conceptually simple code smells</h3>
          <pre><code class="ruby">
            # UncommunicativeMethodName / ParameterName
            def m(a, b, c, d, e, f)  # LongParameterList
              # ClassVariable
              @@klazzy = 42
              call_me(f)
              call_me(f) # DuplicateMethodCall
            end
          </code></pre>
        </section>

        <section>
          <h3>But there are also not so obvious, complicated smells</h3>
          <p class="fragment">Feature Envy occurs when a code fragment references another object more often than it references itself</p>
          <pre class="fragment"><code class="ruby">
              class Warehouse
                def sale_price(item)
                  # We refer to one instance variable (ok)
                  # but call two methods on our
                  # `item` argument (questionable)
                  (item.price - item.rebate) * @vat
                end
              end
          </code></pre>
        </section>

        <section>
          <h3>Reek is a tool that detects code smells</h3>
          <p>Running Reek on</p>
          <pre><code class="ruby">
              class Warehouse
                def sale_price(item)
                  (item.price - item.rebate) * @vat
                end
              end
          </code></pre>
          <img width="48px" height="48px" style="border-style: none" class="fragment" data-src="img/green_arrow_down.png">
          <div><img class="fragment" style="border-style: none" data-src="img/reek_output_for_feature_envy.png"></div>
        </section>

        <section>
          <h3>How does Reek work?</h3>
          <p class="fragment">We use the awesome Parser gem to generate the AST</p>
          <pre class="fragment"><code class="ruby">
            def syntax_tree
              begin
                ast, comments = parser.
                                  parse_with_comments(source, origin)
              rescue Racc::ParseError, Parser::SyntaxError => error
                $stderr.puts "#{origin}: #{error.class.name}: "\
                             "#{error}"
              end
              # snip
            end
          </code></pre>
          <p class="fragment">This will return a tree consisting of <i>Parser::AST::Node</i></p>
        </section>

        <section>
          <p>We wrap that into a tree of contexts</p>
          <pre class="fragment"><code class="ruby">
            def build(exp)
              context_processor = "process_#{exp.type}"
              if context_processor_exists?(context_processor)
                send(context_processor, exp)
              else
                process exp
              end
            end

            def process(exp)
              exp.children.grep(AST::Node).each(&method(:build))
            end
          </code></pre>
        </section>

        <section>
          <p>We then traverse this tree of contexts and run all eligible smell detectors on it</p>
          <pre class="fragment"><code class="ruby">
            class UncommunicativeParameterName < SmellDetector
              def inspect(context)
                context.parameter_names.select do |name|
                  uncommunicative_parameter_name?(name, context)
                end.map do |name|
                  smell_warning("has the parameter name '#{name}'")
                  # ...snip
                end
              end

              def uncommunicative_parameter_name?(name, context)
                !acceptable_name?(name, context) &&
                  context.uses_param?(name)
              end
            end
          </code></pre>
        </section>

        <section>
          <h3>How can you start using Reek?</h3>
          <p class="fragment">Use Reek's Rake task to add it to your CI</p>
          <pre class="fragment"><code class="ruby">
            require 'reek/rake/task'

            Reek::Rake::Task.new do |t|
              t.fail_on_error = false
            end
          </code></pre>
        </section>

        <section>
          <p>Add Reek's custom matchers to your RSpec examples</p>
          <pre class="fragment"><code class="ruby">
            require 'reek'
            require 'reek/spec'
            require 'rspec'

            RSpec.describe 'Reek Integration' do
              it 'works with Reek' do
                smelly_class = 'class C; def m; end; end'
                expect(smelly_class).not_to reek
              end
            end
          </code></pre>
        </section>

        <section>
          <p>Include Reek using the Developer API</p>
          <pre class="fragment"><code class="ruby">
            require 'reek'

            source = <<-EOS
              class Dirty
                def m(a,b,c)
                  puts a,b
                end
              end
            EOS

            reporter = Reek::Report::TextReport.new
            examiner = Reek::Examiner.new source
            reporter.add_examiner examiner
            reporter.show
          </code></pre>
        </section>

        <section>
          <h3>Chapter 3</h3>
          <h4>Mutation testing with Mutant</h4>
          <img data-src="img/supermutant.jpg">
        </section>

        <section>
          <h3>Mutation testing with Mutant</h3>
          <p>Takes code like this</p>
          <pre><code class="ruby">
            class Greeter
              def initialize(phrase)
                @enabled = true
                @phrase = phrase
              end

              def say_hello(options)
                "#{@phrase} #{options[:name]}" if @enabled
              end
            end
          </code></pre>
        </section>

        <section>
          <p>And turns it into something like this</p>
          <pre><code class="ruby">
            if true
              "#{@phrase}#{" "}#{options[:name]}"
            end

            # Was
            # "#{@phrase} #{options[:name]}" if @enabled
          </code></pre>
        </section>

        <section>
          <p>Or this</p>
          <pre><code class="ruby">
            if @enabled
              "#{@phrase}#{" "}#{options.fetch(:name)}"
            end

            # Was
            # "#{@phrase} #{options[:name]}" if @enabled
          </code></pre>
        </section>

        <section>
          <p>Mutant then runs your tests against each mutation</p>
          <!--
            bundle exec mutant --include lib/\
                               --require ast_talk_samples\
                               --use rspec  "Greeter*"
          -->
          <div><img class="fragment" data-src="img/mutant_cli_call.png"></div>
          <img width="48px" height="48px" style="border-style: none" class="fragment" data-src="img/green_arrow_down.png">

          <!--
          Mutant configuration:
          Matcher:         #<Mutant::Matcher::Config match_expressions: [Greeter*]>
          Integration:     Mutant::Integration::Rspec
          Expect Coverage: 100.00%
          Jobs:            4
          Includes:        ["lib/"]
          Requires:        ["ast_talk_samples"]
          Subjects:        2
          -->
          <div><img class="fragment" data-src="img/mutant_configuration_output.png"></div>
        </section>

        <section>
          <p>Failing tests kill the mutants</p>
          <p class="fragment">Surviving mutants show a lack of test coverage</p>
          <!--
              evil:Greeter#say_hello:/Users/timo/dev/ast_talk_samples/lib/mutant/greeter.rb:7:80e67
              @@ -1,6 +1,6 @@
               def say_hello(options)
              -  if @enabled
              +  if true
                   "#{@phrase}#{" "}#{options[:name]}"
                 end
               end
          -->
          <div><img class="fragment" data-src="img/surviving_mutant.png"></div>
        </section>

        <section>
          <h3>How does Mutant work?</h3>
          <!-- TODO ....-->
          <p><b>!!! THIS SECTION IS WIP AT THE MOMENT !!!</b></p>
        </section>

        <section>
          <h3>How can you start using Mutant?</h3>
          <p class="fragment">Include it into your CI</p>
          <div><img class="fragment" data-src="img/mutant_travis_configuration_for_reek.png"></div>
        </section>

        <section>
          <h3>Integrating Mutant into your CI has consequences</h3>
          <p class="fragment">Depending on what you do, your CI runs might become really slow</p>
          <p class="fragment">Your CI runs will fail. A lot...</p>
          <p class="fragment">...because Mutant will uncover holes in your test coverage all the time</p>
        </section>

        <section>
          <h3>Wrapping it up</h3>
          <p class="fragment">If you want to write code that operates on code, ASTs should be your weapon of choice</p>
          <p class="fragment">Don't reinvent the wheel</p>
          <p class="fragment">Love the <a href="https://github.com/whitequark/parser">Parser</a> gem</p>
        </section>

        <section>
          <h3>Thank you!</h3>
          <h4>Questions?</h4>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
  </body>
</html>
